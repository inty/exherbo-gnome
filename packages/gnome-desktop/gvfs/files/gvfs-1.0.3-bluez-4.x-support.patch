diff --git a/ChangeLog b/ChangeLog
index f2076e3..6f8c663 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,61 @@
+2009-02-03  Bastien Nocera  <hadess@hadess.net>
+
+	Bug 570193 â€“ Mounting phone connected via Bluetooth fails
+
+	* daemon/gvfsbackendobexftp.c (_get_bluetooth_device_properties):
+	Use a private connection to connect to the system D-Bus, thanks
+	to Alexander Larsson
+
+2009-02-03  Bastien Nocera  <hadess@hadess.net>
+
+	* daemon/gvfsbackendobexftp.c (do_mount): Fix
+	possible double-free when the display name is freed
+	Avoid errors when the icon name couldn't be gathered
+
+2009-02-02  Bastien Nocera  <hadess@hadess.net>
+
+	Bug 511671 - Make obex-ftp work over usb connections
+
+	* configure.ac: Require HAL for the ObexFTP backend
+	* daemon/Makefile.am:
+	* daemon/gvfsbackendobexftp.c (_get_numbers_from_usb_path),
+	(_is_nokia_3650), (_get_bluetooth_name_and_icon),
+	(_get_bluetooth_device_properties), (_is_same_path),
+	(_find_ods_usb_intfnum), (_get_usb_intfnum_and_properties),
+	(do_mount): Add support for USB ObexFTP devices, original
+	patch from Alexander Kanavin <ak@sensi.org>, requires
+	current obex-data-server trunk
+
+2008-12-01  Bastien Nocera  <hadess@hadess.net>
+
+	* configure.ac: Update bluez requirements, we
+	can't really require the 4.x API without the 4.x
+	libraries...
+
+2008-10-03  Bastien Nocera  <hadess@hadess.net>
+
+	* daemon/gvfsbackendobexftp.c (get_name_and_icon): Use
+	the Alias instead of the Name, so we automatically fallback
+	if the name isn't available
+
+2008-10-02  Bastien Nocera  <hadess@hadess.net>
+
+	* daemon/gvfsbackendobexftp.c: Re-add bluetooth.h include,
+	we still use bachk right now
+
+2008-09-29  Bastien Nocera  <hadess@hadess.net>
+
+	* daemon/gvfsbackendobexftp.c (_is_nokia_3650),
+	(get_name_and_icon), (_get_device_properties),
+	(g_vfs_backend_obexftp_finalize), (g_vfs_backend_obexftp_init),
+	(_query_file_info_helper), (session_connect_error_cb),
+	(session_connected_cb), (do_mount),
+	(g_vfs_backend_obexftp_class_init):
+	* daemon/obexftp-marshal.list:
+	Port to BlueZ 4.x API and obex-data-server SVN API,
+	use the "Icon" property to get the icon, instead of parsing the
+	device class ourselves (#552356)
+
 2008-11-24  Alexander Larsson  <alexl@redhat.com>
 
 	* NEWS:
diff --git a/configure.ac b/configure.ac
index 2888b6f..ad67a47 100644
--- a/configure.ac
+++ b/configure.ac
@@ -259,8 +259,8 @@ msg_obexftp=no
 OBEXFTP_LIBS=
 OBEXFTP_CFLAGS=
 
-if test "x$enable_obexftp" != "xno"; then
-  PKG_CHECK_EXISTS(dbus-glib-1 bluez >= 3.12, msg_obexftp=yes)
+if test "x$enable_obexftp" != "xno" -a "x$msg_hal" = "xyes" ; then
+  PKG_CHECK_EXISTS(dbus-glib-1 bluez >= 4.0, msg_obexftp=yes)
 
   dnl Make sure we have expat
   AC_CHECK_LIB(expat, XML_ParserCreate_MM,
@@ -268,7 +268,7 @@ if test "x$enable_obexftp" != "xno"; then
                have_expat=false)
 
   if test "x$msg_obexftp" == "xyes" -a "x$have_expat" == "xtrue"; then
-    PKG_CHECK_MODULES(OBEXFTP, dbus-glib-1 bluez >= 3.12)
+    PKG_CHECK_MODULES(OBEXFTP, dbus-glib-1 bluez >= 4.0)
     AC_SUBST(OBEXFTP_LIBS)
     AC_SUBST(OBEXFTP_CFLAGS)
 
diff --git a/daemon/Makefile.am b/daemon/Makefile.am
index 57e0308..b950678 100644
--- a/daemon/Makefile.am
+++ b/daemon/Makefile.am
@@ -216,9 +216,10 @@ gvfsd_obexftp_CPPFLAGS = \
 	-DBACKEND_HEADER=gvfsbackendobexftp.h \
 	-DDEFAULT_BACKEND_TYPE=obex \
 	-DMAX_JOB_THREADS=1 \
+	$(HAL_CFLAGS) \
 	-DBACKEND_TYPES='"obex", G_VFS_TYPE_BACKEND_OBEXFTP,'
 
-gvfsd_obexftp_LDADD = $(OBEXFTP_LIBS) $(XML_LIBS) $(libraries)
+gvfsd_obexftp_LDADD = $(OBEXFTP_LIBS) $(XML_LIBS) $(HAL_LIBS) $(libraries)
 
 gvfsd_ftp_SOURCES = \
 	gvfsbackendftp.c gvfsbackendftp.h \
diff --git a/daemon/gvfsbackendobexftp.c b/daemon/gvfsbackendobexftp.c
index 23bea15..91a3721 100644
--- a/daemon/gvfsbackendobexftp.c
+++ b/daemon/gvfsbackendobexftp.c
@@ -28,11 +28,15 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <string.h>
+#include <stdlib.h>
 
 #include <glib/gstdio.h>
 #include <glib/gi18n.h>
 #include <gio/gio.h>
+#include <libhal.h>
 #include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-bindings.h>
+#include <dbus/dbus-glib-lowlevel.h>
 #include <bluetooth/bluetooth.h>
 
 #include "gvfsbackendobexftp.h"
@@ -69,7 +73,8 @@ struct _GVfsBackendObexftp
 
   char *display_name;
   char *bdaddr;
-  guint type;
+  char *icon_name;
+  gint usbintfnum;
 
   DBusGConnection *connection;
   DBusGProxy *manager_proxy;
@@ -96,105 +101,62 @@ typedef struct {
 
 G_DEFINE_TYPE (GVfsBackendObexftp, g_vfs_backend_obexftp, G_VFS_TYPE_BACKEND);
 
-/* This should all live in bluez-gnome, and we
- * should depend on it */
-enum {
-    BLUETOOTH_TYPE_ANY        = 1,
-    BLUETOOTH_TYPE_PHONE      = 1 << 1,
-    BLUETOOTH_TYPE_MODEM      = 1 << 2,
-    BLUETOOTH_TYPE_COMPUTER   = 1 << 3,
-    BLUETOOTH_TYPE_NETWORK    = 1 << 4,
-    BLUETOOTH_TYPE_HEADSET    = 1 << 5,
-    BLUETOOTH_TYPE_KEYBOARD   = 1 << 6,
-    BLUETOOTH_TYPE_MOUSE      = 1 << 7,
-    BLUETOOTH_TYPE_CAMERA     = 1 << 8,
-    BLUETOOTH_TYPE_PRINTER    = 1 << 9 
-};
+static void session_connect_error_cb (DBusGProxy *proxy,
+                                      const char *session_object,
+                                      const gchar *error_name,
+                                      const gchar *error_message,
+                                      gpointer user_data);
+static void session_connected_cb (DBusGProxy *proxy,
+                                  const char *session_object,
+                                  gpointer user_data);
 
-static const char *
-_get_icon_from_type (guint type)
+/* Parse USB paths from do_mount(), or obex-data-server */
+static gboolean
+_get_numbers_from_usb_path (const char *path, int *usb_bus_num, int *usb_device_num, int *usb_intf_num)
 {
-  switch (type)
-    {
-    case BLUETOOTH_TYPE_PHONE:
-      return "phone";
-      break;
-    case BLUETOOTH_TYPE_MODEM:
-      return "modem";
-      break;
-    case BLUETOOTH_TYPE_COMPUTER:
-      return "network-server";
-      break;
-    case BLUETOOTH_TYPE_NETWORK:
-      return "network-wireless";
-      break;
-    case BLUETOOTH_TYPE_HEADSET:
-      return "stock_headphones";
-      break;
-    case BLUETOOTH_TYPE_KEYBOARD:
-      return "input-keyboard";
-      break;
-    case BLUETOOTH_TYPE_MOUSE:
-      return "input-mouse";
-      break;
-    case BLUETOOTH_TYPE_CAMERA:
-      return "camera-photo";
-      break;
-    case BLUETOOTH_TYPE_PRINTER:
-      return "printer";
-      break;
-    default:
-      return "bluetooth";
-      break;
+  char **tokens;
+  char *endp;
+  gboolean has_brackets = FALSE;
+
+  if (path == NULL)
+    return FALSE;
+  if (*path == '[')
+    {
+      path++;
+      has_brackets = TRUE;
     }
-}
 
-static int
-_get_type_from_class (guint class)
-{
-  switch ((class & 0x1f00) >> 8)
+  tokens = g_strsplit (path + 4, ",", 0);
+  if (g_strv_length (tokens) != 3)
     {
-    case 0x01:
-      return BLUETOOTH_TYPE_COMPUTER;
-    case 0x02:
-      switch ((class & 0xfc) >> 2)
-        {
-        case 0x01:
-        case 0x02:
-        case 0x03:
-        case 0x05:
-          return BLUETOOTH_TYPE_PHONE;
-        case 0x04:
-          return BLUETOOTH_TYPE_MODEM;
-        }
-      break;
-    case 0x03:
-      return BLUETOOTH_TYPE_NETWORK;
-    case 0x04:
-      switch ((class & 0xfc) >> 2)
-        {
-        case 0x01:
-          return BLUETOOTH_TYPE_HEADSET;
-        }
-      break;
-    case 0x05:
-      switch ((class & 0xc0) >> 6)
-        {
-        case 0x01:
-          return BLUETOOTH_TYPE_KEYBOARD;
-        case 0x02:
-          return BLUETOOTH_TYPE_MOUSE;
-        }
-      break;
-    case 0x06:
-      if (class & 0x80)
-            return BLUETOOTH_TYPE_PRINTER;
-      if (class & 0x20)
-            return BLUETOOTH_TYPE_CAMERA;
-      break;
+      g_strfreev (tokens);
+      return FALSE;
+    }
+
+ *usb_bus_num = strtol (tokens[0], &endp, 10);
+  if (*endp != '\0')
+    {
+      g_strfreev (tokens);
+      return FALSE;
+    }
+
+  *usb_device_num = strtol (tokens[1], &endp, 10);
+  if (*endp != '\0')
+    {
+      g_strfreev (tokens);
+      return FALSE;
+    }
+
+  *usb_intf_num = strtol (tokens[2], &endp, 10);
+  if ((has_brackets && *endp != ']') || (!has_brackets && *endp != '\0'))
+    {
+      g_strfreev (tokens);
+      return FALSE;
     }
 
-  return BLUETOOTH_TYPE_ANY;
+  g_strfreev (tokens);
+
+  return TRUE;
 }
 
 /* Used to detect broken listings from
@@ -202,75 +164,309 @@ _get_type_from_class (guint class)
 static gboolean
 _is_nokia_3650 (const char *bdaddr)
 {
+  if (!bdaddr)
+    return FALSE;
+
   /* Don't ask, Nokia seem to use a Bluetooth
    * HCI from Murata */
   return g_str_has_prefix(bdaddr, "00:60:57");
 }
 
+static char *
+_get_bluetooth_name_and_icon (DBusGProxy *device, char **icon_name)
+{
+  GHashTable *hash;
+
+  if (dbus_g_proxy_call (device, "GetProperties", NULL,
+                         G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
+                         &hash, G_TYPE_INVALID) != FALSE)
+    {
+      GValue *value;
+      char *name;
+
+      value = g_hash_table_lookup (hash, "Alias");
+      name = value ? g_value_dup_string(value) : NULL;
+
+      value = g_hash_table_lookup (hash, "Icon");
+      if (value)
+        {
+          *icon_name = g_value_dup_string (value);
+        }
+      else
+        {
+          *icon_name = g_strdup ("bluetooth");
+        }
+      g_hash_table_destroy (hash);
+      return name;
+    }
+
+  return NULL;
+}
+
+
+#define _DBUS_POINTER_SHIFT(p)   ((void*) (((char*)p) + sizeof (void*)))
+#define DBUS_G_CONNECTION_FROM_CONNECTION(x)     ((DBusGConnection*) _DBUS_POINTER_SHIFT(x))
+
 static gchar *
-_get_device_properties (const char *bdaddr, guint32 *type)
+_get_bluetooth_device_properties (const char *bdaddr, char **icon_name)
 {
-  DBusGConnection *connection;
+  DBusConnection *conn;
   DBusGProxy *manager;
-  gchar *name, **adapters;
+  GPtrArray *adapters;
+  gchar *name;
   guint i;
 
   name = NULL;
 
-  connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, NULL);
-  if (connection == NULL)
-        return NULL;
+  conn = dbus_bus_get_private (DBUS_BUS_SYSTEM, NULL);
+  if (conn == NULL)
+        return name;
 
-  manager = dbus_g_proxy_new_for_name (connection, "org.bluez",
-                                       "/org/bluez", "org.bluez.Manager");
+  manager = dbus_g_proxy_new_for_name (DBUS_G_CONNECTION_FROM_CONNECTION(conn), "org.bluez",
+                                       "/", "org.bluez.Manager");
   if (manager == NULL)
     {
-      dbus_g_connection_unref (connection);
-      return NULL;
+      dbus_connection_close (conn);
+      dbus_connection_unref (conn);
+      return name;
     }
 
-  if (dbus_g_proxy_call (manager, "ListAdapters", NULL, G_TYPE_INVALID, G_TYPE_STRV, &adapters, G_TYPE_INVALID) == FALSE)
+  if (dbus_g_proxy_call (manager, "ListAdapters", NULL, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &adapters, G_TYPE_INVALID) == FALSE)
     {
       g_object_unref (manager);
-      dbus_g_connection_unref (connection);
-      return NULL;
+      dbus_connection_close (conn);
+      dbus_connection_unref (conn);
+      return name;
     }
 
-  for (i = 0; adapters[i] != NULL; i++)
+  for (i = 0; i < adapters->len && name == NULL; i++)
     {
       DBusGProxy *adapter;
+      char *device_path;
 
-      adapter = dbus_g_proxy_new_for_name (connection, "org.bluez",
-                                           adapters[i], "org.bluez.Adapter");
-      if (dbus_g_proxy_call (adapter, "GetRemoteName", NULL,
+      adapter = dbus_g_proxy_new_for_name (DBUS_G_CONNECTION_FROM_CONNECTION(conn), "org.bluez",
+                                           g_ptr_array_index (adapters, i), "org.bluez.Adapter");
+      if (dbus_g_proxy_call (adapter, "FindDevice", NULL,
                              G_TYPE_STRING, bdaddr, G_TYPE_INVALID,
-                             G_TYPE_STRING, &name, G_TYPE_INVALID) != FALSE)
+                             DBUS_TYPE_G_OBJECT_PATH, &device_path, G_TYPE_INVALID) != FALSE)
+        {
+          DBusGProxy *device;
+          device = dbus_g_proxy_new_for_name (DBUS_G_CONNECTION_FROM_CONNECTION(conn), "org.bluez", device_path, "org.bluez.Device");
+          name = _get_bluetooth_name_and_icon (device, icon_name);
+          g_object_unref (device);
+        }
+      g_object_unref (adapter);
+    }
+
+  g_ptr_array_free (adapters, TRUE);
+  g_object_unref (manager);
+  dbus_connection_close (conn);
+  dbus_connection_unref (conn);
+
+  return name;
+}
+
+static gboolean
+_is_same_path (const char *path, int usb_bus_num, int usb_device_num, int usb_intf_num)
+{
+  int bus, dev, intf;
+
+  if (!_get_numbers_from_usb_path (path, &bus, &dev, &intf))
+    return FALSE;
+
+  if (bus == usb_bus_num &&
+      dev == usb_device_num &&
+      intf == usb_intf_num)
+        return TRUE;
+
+  return FALSE;
+}
+
+static int
+_find_ods_usb_intfnum (DBusGProxy *obex_manager, int device_usb_bus_num, int device_usb_device_num, int device_usb_interface_num)
+{
+  int i, n;
+  GHashTable *hash;
+
+  if (obex_manager == NULL)
+    return -1;
+
+  if (dbus_g_proxy_call (obex_manager, "GetUsbInterfacesNum", NULL, G_TYPE_INVALID, G_TYPE_UINT, &n, G_TYPE_INVALID) == FALSE)
+    return -1;
+
+  for (i = 0; i < n; i++) 
+    {
+      if (dbus_g_proxy_call (obex_manager, "GetUsbInterfaceInfo", NULL,
+                             G_TYPE_UINT, i, G_TYPE_INVALID,
+                             DBUS_TYPE_G_STRING_STRING_HASHTABLE, &hash, 
+                             G_TYPE_INVALID) != FALSE)
         {
-          if (name != NULL && name[0] != '\0')
+          const char* ods_path = g_hash_table_lookup (hash, "Path");
+
+          if (ods_path == NULL)
+            {
+              g_hash_table_destroy (hash);
+              return -2;
+            }
+
+          if (_is_same_path (ods_path, device_usb_bus_num, device_usb_device_num, device_usb_interface_num))
             {
-              guint32 class;
+              g_hash_table_destroy (hash);
+              return i;
+            }
+          g_hash_table_destroy (hash);
+        }
+    }
+  return -1;
+}
 
-              if (dbus_g_proxy_call(adapter, "GetRemoteClass", NULL,
-                                    G_TYPE_STRING, bdaddr, G_TYPE_INVALID,
-                                    G_TYPE_UINT, &class, G_TYPE_INVALID) != FALSE)
-                {
-                  *type = _get_type_from_class (class);
-                }
-              else
+static gint
+_get_usb_intfnum_and_properties (DBusGProxy *obex_manager, const char *device, char **display_name, char **icon_name)
+{
+  char **obex_devices;
+  int num_obex_devices;
+  int usb_bus_num;
+  int usb_device_num;
+  int usb_intf_num;
+  DBusError dbus_error;
+  DBusConnection *dbus_connection;
+  LibHalContext *hal_ctx;
+  int ods_intf_num = 1;
+  int n;
+
+  /* Parse the [usb:1,41,3] string */
+  if (!g_str_has_prefix (device, "[usb:"))
+    {
+      return -1;
+    }
+
+  if (!_get_numbers_from_usb_path (device, &usb_bus_num, &usb_device_num, &usb_intf_num))
+    return -1;
+
+  g_message ("Parsed '%s' into bus=%d device=%d interface=%d", device, usb_bus_num, usb_device_num, usb_intf_num);
+
+  dbus_error_init (&dbus_error);
+  dbus_connection = dbus_bus_get_private (DBUS_BUS_SYSTEM, &dbus_error);
+  if (dbus_error_is_set (&dbus_error))
+    {
+      dbus_error_free (&dbus_error);
+      return -1;
+    }
+  dbus_connection_set_exit_on_disconnect (dbus_connection, FALSE);
+
+  hal_ctx = libhal_ctx_new ();
+  if (hal_ctx == NULL)
+    {
+      dbus_connection_close (dbus_connection);
+      dbus_connection_unref (dbus_connection);
+      dbus_error_free (&dbus_error);
+      return -1;
+    }
+
+  libhal_ctx_set_dbus_connection (hal_ctx, dbus_connection);
+  if (!libhal_ctx_init (hal_ctx, &dbus_error))
+    {
+      libhal_ctx_free (hal_ctx);
+      dbus_connection_close (dbus_connection);
+      dbus_connection_unref (dbus_connection);
+      dbus_error_free (&dbus_error);
+      return -1;
+    }
+  obex_devices = libhal_find_device_by_capability (hal_ctx, "obex", &num_obex_devices, NULL);
+
+  for (n = 0; n < num_obex_devices; n++)
+    {
+      char *udi = obex_devices[n];
+      LibHalPropertySet *ps;
+
+      ps = libhal_device_get_all_properties (hal_ctx, udi, NULL);
+      if (ps != NULL)
+        {
+          const char *subsystem;
+
+          subsystem = libhal_ps_get_string (ps, "info.subsystem");
+          if (subsystem != NULL && strcmp (subsystem, "usb") == 0)
+            {
+              int device_usb_bus_num;
+              int device_usb_device_num;
+              int device_usb_interface_num;
+              const char *icon_from_hal;
+              const char *name_from_hal;
+
+              device_usb_bus_num = libhal_ps_get_int32 (ps, "usb.bus_number");
+              device_usb_device_num = libhal_ps_get_int32 (ps, "usb.linux.device_number");
+              device_usb_interface_num = libhal_ps_get_int32 (ps, "usb.interface.number");
+              icon_from_hal = libhal_ps_get_string (ps, "info.desktop.icon");
+              name_from_hal = libhal_ps_get_string (ps, "info.desktop.name");
+
+              g_message ("looking at usb device '%s' with bus=%d, device=%d interface=%d", 
+                     udi, device_usb_bus_num, device_usb_device_num, device_usb_interface_num);
+
+              if (device_usb_bus_num == usb_bus_num &&
+                  device_usb_device_num == usb_device_num &&
+                  device_usb_interface_num == usb_intf_num)
                 {
-                  *type = BLUETOOTH_TYPE_ANY;
+                  const char *parent_udi;
+
+                  g_message ("udi '%s' matches %s", udi, device);
+                  parent_udi = libhal_ps_get_string (ps, "info.parent");
+
+                  if (parent_udi != NULL)
+                    {
+                      LibHalPropertySet *ps2;
+
+                      ps2 = libhal_device_get_all_properties (hal_ctx, parent_udi, NULL);
+                      if (ps2 != NULL)
+                        {
+                          ods_intf_num = _find_ods_usb_intfnum (obex_manager,
+                                                                device_usb_bus_num,
+                                                                device_usb_device_num,
+                                                                device_usb_interface_num);
+
+                          if (ods_intf_num >= 0)
+                            {
+                              if (icon_from_hal != NULL)
+                                *icon_name = g_strdup (icon_from_hal);
+                              else
+                                *icon_name = "drive-removable-media-usb";
+
+                              if (name_from_hal != NULL)
+                                *display_name = g_strdup (name_from_hal);
+                              else
+                                *display_name = g_strdup_printf ("%s - %s",
+                                                                 libhal_ps_get_string (ps2, "usb_device.vendor"),
+                                                                 libhal_ps_get_string (ps2, "usb_device.product"));
+
+                              libhal_free_property_set (ps2);
+                              libhal_free_property_set (ps);
+
+                              goto end;
+                            }
+                          else if (ods_intf_num == -2)
+                            {
+                              libhal_free_property_set (ps2);
+                              libhal_free_property_set (ps);
+
+                              goto end;
+                            }
+                          libhal_free_property_set (ps2);
+                        }
+                    }
                 }
-              g_object_unref (adapter);
-              break;
             }
+          libhal_free_property_set (ps);
         }
-      g_object_unref (adapter);
     }
 
-  g_object_unref (manager);
-  dbus_g_connection_unref (connection);
+end:
+  libhal_free_string_array (obex_devices);
+  libhal_ctx_free (hal_ctx);
 
-  return name;
+  dbus_connection_close (dbus_connection);
+  dbus_connection_unref (dbus_connection);
+  dbus_error_free (&dbus_error);
+
+  return ods_intf_num;
 }
 
 static void
@@ -282,6 +478,7 @@ g_vfs_backend_obexftp_finalize (GObject *object)
 
   g_free (backend->display_name);
   g_free (backend->bdaddr);
+  g_free (backend->icon_name);
   g_free (backend->files_listing);
   g_free (backend->directory);
 
@@ -312,6 +509,15 @@ g_vfs_backend_obexftp_init (GVfsBackendObexftp *backend)
                                                       "org.openobex",
                                                       "/org/openobex",
                                                       "org.openobex.Manager");
+
+  dbus_g_proxy_add_signal(backend->manager_proxy, "SessionConnectError",
+                          DBUS_TYPE_G_OBJECT_PATH, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INVALID);
+  dbus_g_proxy_connect_signal(backend->manager_proxy, "SessionConnectError",
+                              G_CALLBACK(session_connect_error_cb), backend, NULL);
+  dbus_g_proxy_add_signal(backend->manager_proxy, "SessionConnected",
+                          DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
+  dbus_g_proxy_connect_signal(backend->manager_proxy, "SessionConnected",
+                              G_CALLBACK(session_connected_cb), backend, NULL);
 }
 
 static gboolean
@@ -437,8 +643,7 @@ _query_file_info_helper (GVfsBackend *backend,
       g_file_info_set_file_type (info, G_FILE_TYPE_DIRECTORY);
       g_file_info_set_content_type (info, "inode/directory");
       g_file_info_set_name (info, "/");
-      g_vfs_backend_set_icon_name (backend,
-                                   _get_icon_from_type (op_backend->type));
+      g_vfs_backend_set_icon_name (backend, op_backend->icon_name);
       display = g_strdup_printf (_("%s on %s"), "/", op_backend->display_name);
       g_file_info_set_display_name (info, display);
       g_free (display);
@@ -531,6 +736,37 @@ error_occurred_cb (DBusGProxy *proxy, const gchar *error_name, const gchar *erro
 }
 
 static void
+session_connect_error_cb (DBusGProxy *proxy,
+                          const char *session_object,
+                          const gchar *error_name,
+                          const gchar *error_message,
+                          gpointer user_data)
+{
+  GVfsBackendObexftp *op_backend = G_VFS_BACKEND_OBEXFTP (user_data);
+
+  g_mutex_lock (op_backend->mutex);
+  op_backend->status = ASYNC_ERROR;
+  op_backend->error = g_error_new_literal (DBUS_GERROR,
+                                           DBUS_GERROR_REMOTE_EXCEPTION,
+                                           error_message);
+  g_cond_signal (op_backend->cond);
+  g_mutex_unlock (op_backend->mutex);
+}
+
+static void
+session_connected_cb (DBusGProxy *proxy,
+                      const char *session_object,
+                      gpointer user_data)
+{
+  GVfsBackendObexftp *op_backend = G_VFS_BACKEND_OBEXFTP (user_data);
+
+  g_mutex_lock (op_backend->mutex);
+  op_backend->status = ASYNC_SUCCESS;
+  g_cond_signal (op_backend->cond);
+  g_mutex_unlock (op_backend->mutex);
+}
+
+static void
 cancelled_cb (DBusGProxy *proxy, gpointer user_data)
 {
   GVfsBackendObexftp *op_backend = G_VFS_BACKEND_OBEXFTP (user_data);
@@ -559,24 +795,6 @@ closed_cb (DBusGProxy *proxy, gpointer user_data)
   _exit (1);
 }
 
-static int
-is_connected (DBusGProxy *session_proxy, GVfsJob *job)
-{
-  GError *error = NULL;
-  gboolean connected;
-
-  if (dbus_g_proxy_call (session_proxy, "IsConnected", &error,
-                         G_TYPE_INVALID,
-                         G_TYPE_BOOLEAN, &connected, G_TYPE_INVALID) == FALSE)
-    {
-      g_vfs_job_failed_from_error (job, error);
-      g_error_free (error);
-      return -1;
-    }
-
-  return connected;
-}
-
 static void
 do_mount (GVfsBackend *backend,
           GVfsJobMount *job,
@@ -588,15 +806,14 @@ do_mount (GVfsBackend *backend,
   const char *device;
   GError *error = NULL;
   const gchar *path = NULL;
-  char *server;
   GMountSpec *obexftp_mount_spec;
-  gboolean connected;
+  guint count;
 
   g_print ("+ do_mount\n");
 
   device = g_mount_spec_get (mount_spec, "host");
 
-  if (device == NULL || strlen (device) != BDADDR_LEN + 2)
+  if (device == NULL || (strlen (device) != BDADDR_LEN + 2 && !g_str_has_prefix(device, "[usb:")) )
     {
       g_vfs_job_failed (G_VFS_JOB (job),
                         G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
@@ -604,51 +821,91 @@ do_mount (GVfsBackend *backend,
       return;
     }
 
-  /* Strip the brackets */
-  op_backend->bdaddr = g_strndup (device + 1, 17);
-  if (bachk (op_backend->bdaddr) < 0)
+  op_backend->bdaddr = NULL;
+  op_backend->usbintfnum = -1;
+
+  if (!g_str_has_prefix(device, "[usb:"))
     {
-      g_free (op_backend->bdaddr);
-      g_vfs_job_failed (G_VFS_JOB (job),
-                        G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
-                        _("Invalid mount spec"));
-      return;
+      /* Strip the brackets */
+      op_backend->bdaddr = g_strndup (device + 1, BDADDR_LEN);
+      if (bachk (op_backend->bdaddr) < 0)
+        {
+          g_free (op_backend->bdaddr);
+          g_vfs_job_failed (G_VFS_JOB (job),
+                            G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                            _("Invalid mount spec"));
+          return;
+        }
+    }
+  else
+    {
+      op_backend->usbintfnum = _get_usb_intfnum_and_properties (op_backend->manager_proxy, device, &op_backend->display_name, &op_backend->icon_name);
+      if (op_backend->usbintfnum < 0)
+        {
+          if (op_backend->usbintfnum == -2)
+            {
+              g_vfs_job_failed (G_VFS_JOB (job),
+                                G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                                _("USB support missing. Please contact your software vendor"));
+            }
+          else
+            {
+              g_vfs_job_failed (G_VFS_JOB (job),
+                                G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                                _("Invalid mount spec"));
+            }
+          return;
+        }
     }
 
   /* FIXME, Have a way for the mount to be cancelled, see:
-   * http://bugs.muiline.com/view.php?id=51 */
+   * Use CancelSessionConnect */
+  op_backend->status = ASYNC_PENDING;
 
-  if (dbus_g_proxy_call (op_backend->manager_proxy, "CreateBluetoothSession", &error,
-                         G_TYPE_STRING, op_backend->bdaddr, G_TYPE_STRING, "ftp", G_TYPE_INVALID,
-                         DBUS_TYPE_G_OBJECT_PATH, &path, G_TYPE_INVALID) == FALSE)
+  if (op_backend->bdaddr)
     {
-      g_free (op_backend->bdaddr);
-      g_vfs_job_failed_from_error (G_VFS_JOB (job), error);
-      g_error_free (error);
-      return;
+      if (dbus_g_proxy_call (op_backend->manager_proxy, "CreateBluetoothSession", &error,
+                             G_TYPE_STRING, op_backend->bdaddr, G_TYPE_STRING, "00:00:00:00:00:00", G_TYPE_STRING, "ftp", G_TYPE_INVALID,
+                             DBUS_TYPE_G_OBJECT_PATH, &path, G_TYPE_INVALID) == FALSE)
+        {
+          g_free (op_backend->bdaddr);
+          g_vfs_job_failed_from_error (G_VFS_JOB (job), error);
+          g_error_free (error);
+          return;
+        }
+      op_backend->display_name = _get_bluetooth_device_properties (op_backend->bdaddr, &op_backend->icon_name);
+      if (!op_backend->display_name)
+        op_backend->display_name = g_strdelimit (g_strdup (op_backend->bdaddr), ":", '-');
+      if (!op_backend->icon_name)
+        op_backend->icon_name = g_strdup ("bluetooth");
+      g_print ("  do_mount: %s (%s) mounted\n", op_backend->display_name, op_backend->bdaddr);
+    }
+  else
+    {
+      if (dbus_g_proxy_call (op_backend->manager_proxy, "CreateUsbSession", &error,
+                             G_TYPE_UINT, op_backend->usbintfnum, G_TYPE_STRING, "ftp", G_TYPE_INVALID,
+                             DBUS_TYPE_G_OBJECT_PATH, &path, G_TYPE_INVALID) == FALSE)
+        {
+          g_vfs_job_failed_from_error (G_VFS_JOB (job), error);
+          g_error_free (error);
+          return;
+        }
+      g_print ("  do_mount: usb interface %d mounted\n", op_backend->usbintfnum);
     }
 
   g_vfs_job_set_backend_data (G_VFS_JOB (job), backend, NULL);
-  g_print ("  do_mount: %s mounted\n", op_backend->bdaddr);
 
   op_backend->session_proxy = dbus_g_proxy_new_for_name (op_backend->connection,
                                                          "org.openobex",
                                                          path,
                                                          "org.openobex.Session");
 
-  op_backend->display_name = _get_device_properties (op_backend->bdaddr, &op_backend->type);
-  if (!op_backend->display_name)
-        op_backend->display_name = g_strdup (op_backend->bdaddr);
-
   g_vfs_backend_set_display_name (G_VFS_BACKEND  (op_backend),
                                   op_backend->display_name);
-  g_vfs_backend_set_icon_name (G_VFS_BACKEND (op_backend),
-                               _get_icon_from_type (op_backend->type));
+  g_vfs_backend_set_icon_name (G_VFS_BACKEND (op_backend), op_backend->icon_name);
 
   obexftp_mount_spec = g_mount_spec_new ("obex");
-  server = g_strdup_printf ("[%s]", op_backend->bdaddr);
-  g_mount_spec_set (obexftp_mount_spec, "host", server);
-  g_free (server);
+  g_mount_spec_set (obexftp_mount_spec, "host", device);
   g_vfs_backend_set_mount_spec (G_VFS_BACKEND (op_backend), obexftp_mount_spec);
   g_mount_spec_unref (obexftp_mount_spec);
 
@@ -676,14 +933,20 @@ do_mount (GVfsBackend *backend,
                           G_TYPE_STRING, G_TYPE_STRING, G_TYPE_UINT64, G_TYPE_INVALID);
 
   /* Now wait until the device is connected */
-  connected = is_connected (op_backend->session_proxy, G_VFS_JOB (job));
-  while (connected == FALSE)
-    {
-      g_usleep (G_USEC_PER_SEC / 100);
-      connected = is_connected (op_backend->session_proxy, G_VFS_JOB (job));
-    }
+  count = 0;
+  g_mutex_lock (op_backend->mutex);
+
+  while (op_backend->status == ASYNC_PENDING && count < 100) {
+      GTimeVal val;
+      g_get_current_time (&val);
+      g_time_val_add (&val, 100000);
+      count++;
+      if (g_cond_timed_wait (op_backend->cond, op_backend->mutex, &val) != FALSE)
+            break;
+  }
+  g_mutex_unlock (op_backend->mutex);
 
-  if (connected < 0)
+  if (op_backend->status == ASYNC_ERROR || op_backend->status == ASYNC_PENDING)
     {
       g_message ("mount failed, didn't connect");
 
@@ -694,12 +957,17 @@ do_mount (GVfsBackend *backend,
       g_object_unref (op_backend->session_proxy);
       op_backend->session_proxy = NULL;
 
-      g_vfs_job_failed (G_VFS_JOB (job),
-                        G_IO_ERROR, G_IO_ERROR_BUSY,
-                        _("Connection to the device lost"));
+      if (op_backend->status != ASYNC_PENDING)
+            g_vfs_job_failed_from_error (G_VFS_JOB (job), op_backend->error);
+      else
+            g_vfs_job_failed (G_VFS_JOB (job),
+                              G_IO_ERROR, G_IO_ERROR_BUSY,
+                              _("Connection to the device lost"));
       return;
     }
 
+  op_backend->status = ASYNC_PENDING;
+
   g_vfs_job_succeeded (G_VFS_JOB (job));
 
   g_print ("- do_mount\n");
@@ -1482,6 +1750,12 @@ g_vfs_backend_obexftp_class_init (GVfsBackendObexftpClass *klass)
   /* TransferStarted */
   dbus_g_object_register_marshaller(obexftp_marshal_VOID__STRING_STRING_UINT64,
                                     G_TYPE_NONE, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_UINT64, G_TYPE_INVALID);
+  /* SessionConnected */
+  dbus_g_object_register_marshaller(obexftp_marshal_VOID__STRING,
+                                    G_TYPE_NONE, DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
+  /* SessionConnectError */
+  dbus_g_object_register_marshaller (obexftp_marshal_VOID__STRING_STRING_STRING,
+                                     G_TYPE_NONE, DBUS_TYPE_G_OBJECT_PATH, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INVALID);
 }
 
 /*
diff --git a/daemon/obexftp-marshal.list b/daemon/obexftp-marshal.list
index 985a321..3928c95 100644
--- a/daemon/obexftp-marshal.list
+++ b/daemon/obexftp-marshal.list
@@ -1,2 +1,4 @@
+VOID:STRING
 VOID:STRING,STRING
+VOID:STRING,STRING,STRING
 VOID:STRING,STRING,UINT64
